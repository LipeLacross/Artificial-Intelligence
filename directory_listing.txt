|-- LICENSE
|-- mlp_classification/
  |-- accuracy_report.txt
  |-- iris_mlp_classification.py
|-- mlp_classification_plus/
  |-- classification_analysis.txt
  |-- iris_mlp_classification_plus.py
|-- README.md
|-- README_ENG.md
|-- requirements.txt
|-- search_algorithms/
  |-- atividade_ygor_best_first_search.py
  |-- atividade_ygor_bidirectional_search.py
  |-- atividade_ygor_breadth_first_search.py
  |-- atividade_ygor_depth_first_search.py
  |-- atividade_ygor_uniform_cost_search.py
  |-- grafo_romenia_com_pesos.py


File contents:

|-- LICENSE
|-- mlp_classification/
  |-- accuracy_report.txt
  |-- iris_mlp_classification.py
    Content:
      from sklearn.model_selection import train_test_split
      from sklearn.neural_network import MLPClassifier
      from sklearn.datasets import load_iris
      from sklearn.metrics import accuracy_score
      
      # Carrega os dados
      iris = load_iris()
      X = iris.data  # Características
      y = iris.target  # Classes
      
      # Divide em treino e teste (70% treino, 30% teste)
      X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
      
      # Cria o MLP com 10 neurônios
      mlp = MLPClassifier(hidden_layer_sizes=(10,), max_iter=1000, random_state=42)
      
      # Treina o modelo
      mlp.fit(X_train, y_train)
      
      # Faz previsões
      y_pred = mlp.predict(X_test)
      
      # Calcula a acurácia
      accuracy = accuracy_score(y_test, y_pred)
      
      # Cria um arquivo .txt com a acurácia
      with open("accuracy_report.txt", "w") as f:
          f.write(f"Acuracia: {accuracy * 100:.2f}%\n")
      
      # Exibe a acurácia
      print(f"Acurácia: {accuracy * 100:.2f}%")
|-- mlp_classification_plus/
  |-- classification_analysis.txt
  |-- iris_mlp_classification_plus.py
    Content:
      import numpy as np
      from sklearn.model_selection import train_test_split
      from sklearn.neighbors import KNeighborsClassifier
      from sklearn.tree import DecisionTreeClassifier
      from sklearn.svm import SVC
      from sklearn.neural_network import MLPClassifier
      from sklearn.datasets import load_iris
      from sklearn.metrics import accuracy_score
      
      iris = load_iris()
      X = iris.data  # Características
      y = iris.target  # Classes
      
      # Divide em treino (70%) e teste (30%)
      X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
      
      # Inicializa os classificadores
      classifiers = {
          "KNN": KNeighborsClassifier(),
          "C4.5 (Decision Tree)": DecisionTreeClassifier(random_state=42),
          "SVM": SVC(),
          "MLP": MLPClassifier(hidden_layer_sizes=(10,), max_iter=1000, random_state=42)
      }
      
      # Treina e avalia cada classificador
      accuracies = {}
      for name, clf in classifiers.items():
          clf.fit(X_train, y_train)
          y_pred = clf.predict(X_test)
          accuracies[name] = accuracy_score(y_test, y_pred)
      
      # Salva os resultados em um arquivo .txt
      with open("classification_analysis.txt", "w") as f:
          f.write("Comparacao de Algoritmos para Classificacao do Iris Dataset\n\n")
          for name, acc in accuracies.items():
              f.write(f"{name}: Acuracia = {acc * 100:.2f}%\n")
      
      # Exibe a acurácia de cada modelo
      for name, acc in accuracies.items():
          print(f"{name}: Acuracia = {acc * 100:.2f}%")
|-- README.md
|-- README_ENG.md
|-- requirements.txt
|-- search_algorithms/
  |-- atividade_ygor_best_first_search.py
    Content:
      from queue import PriorityQueue
      from grafo_romenia_com_pesos import RomeniaPonderado
      
      class Node:
          def __init__(self, city, cost):
              self.city = city  # cidade de agora
              self.cost = cost  # custo total até chegar nessa cidade
      
          #comparar nós, baseado no custo
          def __lt__(self, other):
              return self.cost < other.cost
      
      class SearchTree:
          def __init__(self, graph):
              self.graph = graph  #grafo com as cidades e distâncias
              self.frontier = PriorityQueue()  # fronteira usando uma fila de prioridade
              #slide do prof ->fila de prioridade remove primeiro o nó com o menor custo, de acordo com alguma função de avaliação
              
              self.explored = set()  # lista de cidades já exploradas
      
          def best_first_search(self, start, goal):
              # add a cidade inicial na fronteira com dist 0
              self.frontier.put(Node(start, 0))
      
              #enquanto tiver nós na fronteira
              while not self.frontier.empty():
                  #pega nó com menor custo
                  current_node = self.frontier.get()
                  current_city = current_node.city
      
                  #se a cidade já foi explorada, vai para a próxima iteração
                  if current_city in self.explored:
                      continue
      
                  # torna a cidade como explorada
                  self.explored.add(current_city)
      
                  # se a cidade atual é destino, retorna o custo total
                  if current_city == goal:
                      return current_node.cost
      
                  # pra cada cidade vizinha da cidade atual
                  for neighbor in self.graph.G.neighbors(current_city):
                      # Se cidade vizinha ainda não foi explorada
                      if neighbor not in self.explored:
                          # calc o cust total para chegar a cidade vizinha
                          edge_weight = self.graph.G[current_city][neighbor]['weight']
                          total_cost = current_node.cost + edge_weight
                          # add cidade vizinha na fronteira
                          self.frontier.put(Node(neighbor, total_cost))
      
              # None se não achar nada
              return None
      
      if __name__ == "__main__":
          romania = RomeniaPonderado()
          #tree com grafo
          search_tree = SearchTree(romania)
      
          start_city = "Arad"
          goal_city = "Bucharest"
          result = search_tree.best_first_search(start_city, goal_city)
          print(f"O caminho mais curto de {start_city} para {goal_city} tem o custo de {result} km.")
  |-- atividade_ygor_bidirectional_search.py
    Content:
      from collections import deque
      from grafo_romenia_com_pesos import RomeniaPonderado
      
      class BidirectionalSearch:
          def __init__(self, graph):
              self.graph = graph  # grafo com as cidades e distâncias
      
          def bidirectional_search(self, start, goal):
              if start == goal:
                  return 0
      
              # Fila para a busca a partir do início
              queue_start = deque([(start, 0)])
              visited_start = {start: 0}
      
              # Fila para a busca a partir do objetivo
              queue_goal = deque([(goal, 0)])
              visited_goal = {goal: 0}
      
              while queue_start and queue_goal:
                  # Expande a busca a partir do início
                  current_city_start, current_cost_start = queue_start.popleft()
                  for neighbor in self.graph.G.neighbors(current_city_start):
                      new_cost = current_cost_start + self.graph.G[current_city_start][neighbor]['weight']
                      if neighbor in visited_goal:
                          return new_cost + visited_goal[neighbor]
                      if neighbor not in visited_start:
                          visited_start[neighbor] = new_cost
                          queue_start.append((neighbor, new_cost))
      
                  # Expande a busca a partir do objetivo
                  current_city_goal, current_cost_goal = queue_goal.popleft()
                  for neighbor in self.graph.G.neighbors(current_city_goal):
                      new_cost = current_cost_goal + self.graph.G[current_city_goal][neighbor]['weight']
                      if neighbor in visited_start:
                          return new_cost + visited_start[neighbor]
                      if neighbor not in visited_goal:
                          visited_goal[neighbor] = new_cost
                          queue_goal.append((neighbor, new_cost))
      
              # Retorna None se não encontrar o caminho
              return None
      
      if __name__ == "__main__":
          romania = RomeniaPonderado()
          bidirectional = BidirectionalSearch(romania)
      
          start_city = "Arad"
          goal_city = "Bucharest"
          result = bidirectional.bidirectional_search(start_city, goal_city)
          print(f"Busca Bidirecional: O caminho mais curto de {start_city} para {goal_city} tem o custo de {result} km.")
  |-- atividade_ygor_breadth_first_search.py
    Content:
      from collections import deque
      from grafo_romenia_com_pesos import RomeniaPonderado
      
      class BFS:
          def __init__(self, graph):
              self.graph = graph  # grafo com as cidades e distâncias
      
          def bfs_search(self, start, goal):
              queue = deque([(start, 0)])  # fila para a busca, contendo o nó e o custo
              visited = set()  # conjunto de cidades já visitadas
      
              while queue:
                  current_city, current_cost = queue.popleft()
      
                  # Se a cidade atual é o destino, retorna o custo total
                  if current_city == goal:
                      return current_cost
      
                  # Marca a cidade atual como visitada
                  visited.add(current_city)
      
                  # Para cada cidade vizinha da cidade atual
                  for neighbor in self.graph.G.neighbors(current_city):
                      if neighbor not in visited:
                          # Adiciona a cidade vizinha na fila
                          queue.append((neighbor, current_cost + self.graph.G[current_city][neighbor]['weight']))
      
              # Retorna None se não encontrar o caminho
              return None
      
      if __name__ == "__main__":
          romania = RomeniaPonderado()
          bfs = BFS(romania)
      
          start_city = "Arad"
          goal_city = "Bucharest"
          result = bfs.bfs_search(start_city, goal_city)
          print(f"BFS: O caminho mais curto de {start_city} para {goal_city} tem o custo de {result} km.")
  |-- atividade_ygor_depth_first_search.py
    Content:
      from grafo_romenia_com_pesos import RomeniaPonderado
      
      class DFS:
          def __init__(self, graph):
              self.graph = graph  # grafo com as cidades e distâncias
      
          def dfs_search(self, start, goal):
              stack = [(start, 0)]  # pilha para a busca, contendo o nó e o custo
              visited = set()  # conjunto de cidades já visitadas
      
              while stack:
                  current_city, current_cost = stack.pop()
      
                  # Se a cidade atual é o destino, retorna o custo total
                  if current_city == goal:
                      return current_cost
      
                  # Marca a cidade atual como visitada
                  visited.add(current_city)
      
                  # Para cada cidade vizinha da cidade atual
                  for neighbor in self.graph.G.neighbors(current_city):
                      if neighbor not in visited:
                          # Adiciona a cidade vizinha na pilha
                          stack.append((neighbor, current_cost + self.graph.G[current_city][neighbor]['weight']))
      
              # Retorna None se não encontrar o caminho
              return None
      
      if __name__ == "__main__":
          romania = RomeniaPonderado()
          dfs = DFS(romania)
      
          start_city = "Arad"
          goal_city = "Bucharest"
          result = dfs.dfs_search(start_city, goal_city)
          print(f"DFS: O caminho mais curto de {start_city} para {goal_city} tem o custo de {result} km.")
  |-- atividade_ygor_uniform_cost_search.py
    Content:
      import heapq
      from grafo_romenia_com_pesos import RomeniaPonderado
      
      class UniformCostSearch:
          def __init__(self, graph):
              self.graph = graph  # grafo com as cidades e distâncias
      
          def uniform_cost_search(self, start, goal):
              priority_queue = [(0, start)]  # fila de prioridade com custo inicial 0
              visited = set()  # conjunto de cidades já visitadas
              costs = {start: 0}  # dicionário para armazenar o custo mínimo para cada cidade
      
              while priority_queue:
                  current_cost, current_city = heapq.heappop(priority_queue)
      
                  # Se a cidade atual é o destino, retorna o custo total
                  if current_city == goal:
                      return current_cost
      
                  # Marca a cidade atual como visitada
                  visited.add(current_city)
      
                  # Para cada cidade vizinha da cidade atual
                  for neighbor in self.graph.G.neighbors(current_city):
                      edge_weight = self.graph.G[current_city][neighbor]['weight']
                      new_cost = current_cost + edge_weight
      
                      # Se o vizinho não foi visitado ou encontramos um caminho mais barato
                      if neighbor not in visited and (neighbor not in costs or new_cost < costs[neighbor]):
                          costs[neighbor] = new_cost
                          heapq.heappush(priority_queue, (new_cost, neighbor))
      
              # Retorna None se não encontrar o caminho
              return None
      
      if __name__ == "__main__":
          romania = RomeniaPonderado()
          ucs = UniformCostSearch(romania)
      
          start_city = "Arad"
          goal_city = "Bucharest"
          result = ucs.uniform_cost_search(start_city, goal_city)
          print(f"UCS: O caminho mais curto de {start_city} para {goal_city} tem o custo de {result} km.")
  |-- grafo_romenia_com_pesos.py
    Content:
      import matplotlib.pyplot as plt
      import networkx as nx
      
      
      class RomeniaPonderado:
          def __init__(self):
              # Criar um grafo
              self.G = nx.Graph()
      
              # Adicionar as arestas com pesos (distâncias)
              edges = [
                  ("Arad", "Zerind", 75),
                  ("Arad", "Sibiu", 140),
                  ("Arad", "Timisoara", 118),
                  ("Zerind", "Oradea", 71),
                  ("Oradea", "Sibiu", 151),
                  ("Timisoara", "Lugoj", 111),
                  ("Lugoj", "Mehadia", 70),
                  ("Mehadia", "Drobeta", 75),
                  ("Drobeta", "Craiova", 120),
                  ("Sibiu", "Fagaras", 99),
                  ("Sibiu", "Rimnicu Vilcea", 80),
                  ("Rimnicu Vilcea", "Pitesti", 97),
                  ("Rimnicu Vilcea", "Craiova", 146),
                  ("Craiova", "Pitesti", 138),
                  ("Fagaras", "Bucharest", 211),
                  ("Pitesti", "Bucharest", 101),
                  ("Giurgiu", "Bucharest", 90),
                  ("Bucharest", "Urziceni", 85),
                  ("Urziceni", "Hirsova", 98),
                  ("Urziceni", "Vaslui", 142),
                  ("Vaslui", "Iasi", 92),
                  ("Iasi", "Neamt", 87),
                  ("Hirsova", "Eforie", 86)
              ]
      
              # Adicionar as arestas ao grafo
              for edge in edges:
                  self.G.add_edge(edge[0], edge[1], weight=edge[2])
      
          def imprimir(self):
              # Imprimir o grafo com as distâncias
              for u, v, weight in self.G.edges(data=True):
                  print(f"De {u} para {v} com distância {weight['weight']} km")
      
          def plotar(self):
              # Desenhar o grafo
              pos = nx.spring_layout(self.G)  # Gera uma disposição dos nós
              nx.draw(self.G, pos, with_labels=True, node_color='lightblue', edge_color='#909090', node_size=500, font_size=8,
                      font_weight='bold')
      
              # Adicionar rótulos de peso às arestas
              edge_labels = nx.get_edge_attributes(self.G, 'weight')
              nx.draw_networkx_edge_labels(self.G, pos, edge_labels=edge_labels)
      
              plt.title("Mapa de Cidades da Romênia com Distâncias")
              plt.show()
